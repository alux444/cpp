
# lvalue vs rvalue

lvalue: locator value - any value with an addressable object in memory
rvalue: read value - any temporary value or literal without a persistent address

# const lvalue

```cpp
int x {5};
const int& ref {x}; // non modifiable reference of x
```

otherwise we can do something like `ref = 6` - which would do the same as `x = 5`, modifying the original reference

# conversions

if any conversion occurs to the type of the bound object and the original reference gets modified, the changes won't be propagated because it's a different object

```cpp
short x {5};
const int& y {x};
--x; // only affects x. y will remain the same (5)
```

# constexpr references

can only be bound to objects with static duration (globals or static locals)

```cpp
int g_x { 5 };

int main()
{
    [[maybe_unused]] constexpr int& ref1 { g_x }; // ok, can bind to global

    static int s_x { 6 };
    [[maybe_unused]] constexpr int& ref2 { s_x }; // ok, can bind to static local

    int x { 6 };
    [[maybe_unused]] constexpr int& ref3 { x }; // compile error: can't bind to non-static object

    return 0;
}
```
